defmodule Mix.Tasks.Compile.Surface do
  @moduledoc """
  Generate CSS and JS/TS assets for components.

  ## Setup

  Update `mix.exs`, adding the `:surface` compiler to the list of compilers:

  ```elixir
  def project do
    [
      ...,
      compilers: [:phoenix] ++ Mix.compilers() ++ [:surface]
    ]
  end
  ```

  ## Configuration (optional)

  The Surface compiler provides some options for custom configuration in your `config/dev.exs`.

  ### Options

  * `hooks_output_dir` - defines the folder where the compiler generates the JS hooks files.
    Default is `./assets/js/_hooks/`.

  * `css_output_file` - defines the css file where the compiler generates the code.
    Default is `./assets/css/_components.css`.

  * `code_reload` - a set of options defining how to interact with phoenix's code reloader
    and phoenix whatchers (e.g. Esbuild, Tailwind, etc.). See available options below.

  ### Code reload options

  * `assets_depending_on_css_output` - the list of assets that depend on the `css_output_file`
    generated by the surface compiler. When defined, the compiler will wait for those assets
    to be rebuilt so phoenix can sent their updated version to the browser after code reloading.

  * `assets_depending_on_hooks_output` - the list of assets that depend on the hooks generated by
    the surface compiler in `hooks_output_dir`. When defined, the compiler will wait for those
    assets to be rebuilt so phoenix can sent their updated version to the browser after code
    reloading.

  * `wait_for_assets_timeout` - the time in miliseconds to wait for assets to be rebuilt.
    Default is `2000` (2 seconds). You should increase this value in case your watcher takes
    longer to build the assets. Pay attention that, on timeout, the compiler will emit a warning
    without halting compilation.

  ### Example

      config :surface, :compiler,
        hooks_output_dir: "assets/js/surface",
        css_output_file: "assets/css/surface.css",
        code_reload: [
          wait_for_assets_timeout: 3000,
          assets_depending_on_css_output: ["priv/static/assets/app.css"],
          assets_depending_on_hooks_output: ["priv/static/assets/app.js"]
        ]

  """

  use Mix.Task
  @recursive true
  @manifest ".compile_surface"
  @manifest_version 1

  alias Mix.Task.Compiler.Diagnostic

  @switches [
    return_errors: :boolean,
    warnings_as_errors: :boolean
  ]

  @doc false
  def run(args) do
    # Do nothing if it's a dependency. We only have to run it once for the main project
    if "--from-mix-deps-compile" in args do
      {:noop, []}
    else
      {compile_opts, _argv, _err} = OptionParser.parse(args, switches: @switches)
      opts = Application.get_env(:surface, :compiler, [])
      asset_opts = Keyword.take(opts, [:hooks_output_dir, :css_output_file, :code_reload])
      asset_components = Surface.components()
      project_components = Surface.components(only_current_project: true)

      {asset_diagnostics, signatures} = Mix.Tasks.Compile.Surface.AssetGenerator.run(asset_components, asset_opts)

      {version, old_signatures} = read_manifest()

      if version != @manifest_version or old_signatures != signatures do
        write_manifest!(signatures)
      end

      [
        Mix.Tasks.Compile.Surface.ValidateComponents.validate(project_components),
        asset_diagnostics
      ]
      |> List.flatten()
      |> handle_diagnostics(compile_opts)
    end
  end

  @doc false
  def handle_diagnostics(diagnostics, compile_opts) do
    case diagnostics do
      [] ->
        {:noop, []}

      diagnostics ->
        if !compile_opts[:return_errors], do: print_diagnostics(diagnostics)
        status = status(compile_opts[:warnings_as_errors], diagnostics)

        {status, diagnostics}
    end
  end

  defp print_diagnostics(diagnostics) do
    for %Diagnostic{message: message, severity: severity, file: file, position: position} <- diagnostics do
      print_diagnostic(message, severity, file, position)
    end
  end

  defp print_diagnostic(message, :warning, file, line) do
    # Use IO.warn(message, file: ..., line: ...) on Elixir v1.14+
    rel_file = file |> Path.relative_to_cwd() |> to_charlist()
    IO.warn(message, [{nil, :__FILE__, 1, [file: rel_file, line: line]}])
  end

  defp print_diagnostic(message, :error, file, line) do
    error = IO.ANSI.format([:red, "error: "])

    stacktrace =
      "  #{file}" <>
        if(line, do: ":#{line}", else: "")

    IO.puts(:stderr, [error, message, ?\n, stacktrace])
  end

  defp status(warnings_as_errors, diagnostics) do
    cond do
      Enum.any?(diagnostics, &(&1.severity == :error)) -> :error
      warnings_as_errors && Enum.any?(diagnostics, &(&1.severity == :warning)) -> :error
      true -> :ok
    end
  end

  @doc false
  def manifests, do: [manifest()]

  defp manifest, do: Path.join(Mix.Project.manifest_path(), @manifest)

  @doc false
  def read_manifest do
    case File.read(manifest()) do
      {:ok, contents} -> :erlang.binary_to_term(contents)
      _ -> {:unknown, nil}
    end
  end

  defp write_manifest!(signatures) do
    File.write!(manifest(), :erlang.term_to_binary({@manifest_version, signatures}))
  end
end
